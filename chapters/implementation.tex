\chapter{Implementation}
\section{Input}	% svg files, why vector is better than raster
For the implementation of the presented algorithms a input format had to be specified. As already mentioned in the requirements, it was desired that the input would be easy to edit for artists. That implies that a proper editing tool should be available. To create drawings basically two types of representation are existing: Raster images and vector graphics. Raster images work on a \textit{pixel} basis. Each pixel is saved as respective color value depending on the color space (grayscale, indexed or RGB are common). Lossy compression for raster images is available. Scaling raster graphics is limited by the resolution the image was saved in.

In contrast, vector graphics have infinite resolution because they define the image in terms of mathematical functions. Vector graphics contain information about seperate elements where raster graphics do only contain color information and don't have any concept of \enquote{element}. That makes it easy to retrieve and store metadata and, for example, parse the color of a line or area.

Due to the mentioned points it was easy to decide that vector graphics will be used as input for the path generator program. Several excellent editors are existing, such as Inkscape, which was already mentioned in the beginning, or Adobe® Illustrator®, which basically is a graphics industry standard.

Since vector graphics is only a concept, a file format had to be specified as well. A number of proprietary formats, like the Adobe® Illustrator® format (\texttt{.ai}) are available, but because of their proprietary nature have been ruled out. The most widely supported format for vector graphics is the Scalable Vector Graphics (SVG) specification, which is an open standard format, defined by the SVG Working Group\cite{svgstandard}. Rendering SVG is supported in all major web browsers and most modern user interface toolkits such as QT or GTK+. SVG is based on the Extended Markup Language (XML), for which a number of proprietary and open source parsers are available, thus making it easy to build upon.

\section{SVG Parser}

The main part of the SVG specification that we needed to implement is the path parsing. A path, in SVG, is represented by a sequence of commands. A command is a lower- or uppercase letter followed by a list of coordinates
\footnote{\url{http://www.w3.org/TR/SVG/paths.html}}. Coordinates following uppercase letters indicate \textit{absolute} coordinates and lowercase letter are followed by \textit{relative} coordinates. It is stateful in the way that for correct parsing the previous coordinate has to be known, except for the \texttt{M} (Move To) command.

A not complete list of possible commands is listed below:

\begin{description}
\item[\texttt{[M/m] (x,y)+}] Move To command. Starts a new (sub-)path at x,y.
\item[\texttt{[L/l] (x,y)+}] Line To command. Draws a straight line from the previous coordinate to the current coordinate.
\item[\texttt{[C/c] (x1, y1, x2, y2, x3, y3)+}] Curve To command. Defines a cubic Beziér curve with 4 control points.
\item[\texttt{Z}] Closes the element.
\end{description} 

The SVG Parser is implemented in the Python programming language. After an initial attempt to use an implementation by ourselves, it reached a certain limit of complexity that was needed to deal with output produced by Inkscape, and a rewrite would have been imminent. Our implementation did not pay respect to elementwise transforms nor to inheritance of group transforms, where a parsing tree structure would be needed. Luckily, a good implementation of all necessary features for the path generation was found online, called \enquote{svg} \footnote{\url{https://github.com/cjlano/svg}}.

It was enhanced by an attribute parser and some smaller changes to the inner workings were made to produce the necessary output. The SVG parser also has functions to reduce Beziér splines to a polyline by evaluating the polynomial at certain, linearly distributed intervals of $t$. The resulting points are not equally spaced, which is a property of Beziér curves. The points are, however, more densly spaced in regions where the curvature is higher and that is actually positive as the region with the most change gets the most \enquote{attention}. 

A wrapper script was created that exports two functions to the main path generator and passes the parsed objects.	

\section{Element Polymorphism}

An element container class exists from which three different classes are derived (corresponding to the three defined image elements). The classes are \texttt{PolyLineElementPtr}, \texttt{PolygonElementPtr} and \texttt{FilledPolygonElementPtr}.

Some common properties are:

\begin{description}

\item[\texttt{\textcolor{blue}{int} getSize()}] Returns the size of the container holding the vertices.

\item[\texttt{\textcolor{blue}{Point\_2} getFromIndex(\textcolor{blue}{int} idx)}] Returns the point at index. This feature is implemented as circulator by taking the modulo: 
\texttt{return element[idx mod element.size()];}. 
It is useful for accessing the polyon elements as well as the end of a polyline, which can be accessed by calling the
function with \texttt{idx = -1;}.

\item[\texttt{\textcolor{blue}{ElementPtr} * to, from;}]
\item[\texttt{\textcolor{blue}{Point\_2} entryPoint, exitPoint}] Those two items keep track of the tour through the drawing. The pointers \texttt{from} and \texttt{to} keep track of the previous and next element, 
\texttt{exitPoint}- and \texttt{entryPoint} are the points on the element where the tour is entering and leaving.

\item[\texttt{\textcolor{blue}{TourConnector} enforcedConnection[2];}] An element can have enforced connections to at most two other elements. The tour connector class stores the exit- or entry node (it is not known in which direction a polyline is traversed) as well as the target element.

\item[\vv{int}{enforcedStartIndex}] Stores an optional enforced start index if the traversal of the element should be started at that this index.

\item[\vv{int}{getType();}] returns element type (can be one of \texttt{EL\_POLYLINE}, \texttt{EL\_POLYGON}, \texttt{EL\_FILLED\_POLYGON}, which are defined in a enumeration).



\end{description}

They derive a number of virtual and pure virtual functions from the base class

	\section{Tree Container}

All elements are sorted into a tree structure. The tree strucure was initially chosen to keep track of all containment 

\section{Preprocessing}

In the preprocessing phase of the program, the bounding box of all elements is calculated and they are scaled and translated to the field. An optional margin can be set to the field.

\section{Implementation of the Algorithms}

All core geometric algorithms have been provided by the \textit{Computer Geometric Algorithms Library}\cite{cgal:eb-00a} (CGAL). 

\section{Post Processing}

After the complete trajectory for the drawing process was evaluated and, eventually modified, in the graphical user interface, the post processing step does two different things.

First, the edges of the trajectory are rounded. The fill elements are receiving an inner rounding, whereas the outer elements (polygon boundaries) are rounded by analysing a threshold angle. If the angle is too sharp, the trajectory will create an outer loop so that the edges will stay sharp (illustrated in \autoref{fig:rounding}. Otherwise, the rounding is also on the inner side.
x
In the last step, all connecting curves are discretized to polylines and the complete trajectory is equally spaced with points and corresponding rake states, so that it can easily be handled by the \textit{Path Converter} (another bachelor thesis) or directly be passed to the point following controller of the BeachBot, .

\section{User Interface}

The graphical user interface (GUI) was implemented in \textit{Javascript}, or, more specifically in \textit{CoffeeScript}, which is a strict superset of Javascript. The \textit{paper.js} library was used for drawing and provides most of the abstractions used throughout the program. A python server is used as slim host of the main application. The application provides means to parse and send JSON serializations of the complete vector element tree, which are parsed in Javascript user interface. All data is sent and retrieved using asynchronous \texttt{GET} and \texttt{POST} requests (commonly referred to as \textit{AJAX}). This implemetation was chosen to allow for great flexibilty in terms of devices accessing the server. A seperate bachelor thesis was working on a Android tablet based touch interface to control the BeachBot. Since Android tablets are perfectly capable of including a \textit{WebView} component which could easily serve the \textit{HTML} and Javascript files developed in this bachelor thesis, integration of those two tools should be easy. The main program also compiles on the internal computer of the BeachBot, where the server could possibly run, allowing for a fully integrated system. As mentioned in the section about the \texttt{ElementPtr}, all elements have a unique identifier number which makes it easy to select them programmatically and what is used by several of the GUIs methods.

Three different view modes and four tools have been implemented which have proven to be helpful in the design of useful trajectories for the BeachBot.

\subsection{Views} The \textit{Outline} view is the standard view, where all paths of the image are displayed with a stroke width of 2 pixels. A \textit{Realistic} view tries to approximate the real rake size of the generated trajectory by using a stroke width that corresponds to the real world dimensions. Empirical data shows that the conversion does work quite well. The connections can also be displayed differently. If \textit{Show Connections} is selected, all connecting trajectories are rendered in blue color on the screen. Selecting \textit{Simple Connection}, the connections are rendered as directed arrows, which is useful for changing and analyzing the TSP solution. \textit{No Connections} hides all the connecting trajectories. All view code was implemented clientside (in Javascript).

\subsection{Tools}

Paper.js offers a useful tool abstraction, which makes the creation of various tools very flexible. 4 different tools have been implemented:

\begin{description}
\item[Change Connection Tool] As mentioned, the \texttt{ElementPtr} can store enforced connections between elements. Selecting the first or last node of a polyline or any node of a polygon element, and subsequently the same on another element adds an enforced connection between those elements at the desired nodes, and also deletes any previous enforced connection between the node and any other element.
\item[Shape Transitions Tool] The transitions, as they are a number of Beziér curves, sometimes have to be modified because they cross an area or show otherwise undesired behaviour. While for example the crossing of already drawn areas could also be mitigated in the code, it was not possible to do so in the scope of this bachelor thesis. The shape transitions tool offers a convenient way to so: Just like in vector graphcis programs the node can be selected, which then also shows its handles. The node itself can be moved, or the handles can be moved. However, the rotation of the handles (which influences the continuity of the curve, is kept so that both handles form a straight line (the length of the handle vector is not influenced by an operation on the other one).
\item[Select Fill Tool] As discussed, two different fill mechanisms are available: The spiral fill and the back and forth fill. Selecting a convex segment of a partitioned polygon, a vector can be drawn that indictates the desired direction of back-and-forth fill for the selected segment. In the same way, the selected segment can also be chosen to be filled by a spiral by clicking the \textit{Use Spiral Fill} button.
\item[Segmentation Tool] If the segmentation of a polygon is not as desired, the segmentation tool can be used to resegment the polygon. Drawing a line from any point to another sends a segmentation request to the server. If any of the filled polygons is intersecting with the drawn line segment, the polygon will be cutted along it, yielding two or more polygons. Afterwards, the optimal convex partitioning is executed on each of the new segments.
\end{description} 
