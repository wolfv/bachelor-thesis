\chapter{Path Planning Algorithms}
\section{Algorithm Overview}

The output of the path generator should be a single trajectory that completely connects and covers all elements of the drawing.

Derived from the requirements, three different elements were identified as part of drawing (illustrated in \autoref{fig:elements_def}):

\begin{description}
\item[Polyline] A line consisting of $2$ to $n$ vertices
\item[Polygon] A closed line, consisting of $2$ to $n$ vertices, where the last segment is a closing one. So that vertex $v_{n+1}$ equals $v_0$.
\item[Filled Polygon] Defined in the same way as the polygon, except that the inner space should be filled by a generated trajectory. Another difference is that the filled polygon can also contain holes, which should not be covered and be excluded from the fill trajectory.
\end{description}

The path generation happens in three steps: First, the polygons that have to be filled are selected and the fill algorithm is seperately executed for each of the polygons with polygon specific settings. In a second step all of the drawing elements are connected by an open tour and a Traveling Salesman heuristic minimizes the total driving distance. As last step, the connections are shaped with curves that conform to  a curvature limit.

Each of those steps will be discussed in detail in this section.

\begin{figure}
\centering
\includegraphics[width=0.6\textwidth]{images/path_planning/line_polygon_definition.pdf}
\caption{Polyline, polygon and filled polygon}
\label{fig:elements_def}
\end{figure}

% you discuss the lines, closed lines, filled polygons
% then you explain the structure that you work on elements separately and the connect them with TSP.
\section{Polygon Filling}

\subsection{Related Work}

Over time several complete coverage algorithms have been developed, and some distinctions can be made. 

One category of solutions for the surface coverage  was developed for robots that do not know the surroundings beforehand and use a variant of \textit{simultaneous localization and mapping} (SLAM) to gather knowledge of the environment. 

Coverage algorithms exist for household applications like autonomous vacuum cleaners or autonomous lawn mowers but also search and rescue robots usually and they  do not care if they visit the same spot twice. The target for those algorithms is rather to achieve complete coverage of an previously unknown terrain in sensible time. Usually, the complete surface coverage algorithms in are also connected with online map generation techniques \textit{SLAM}, whereas the path generation for the BeachBot should happen offline.

However, in agricultural applications some interesting algorithms have been found, which served as inspiration for the explorations presented in this thesis. Especially \citep{ROB:ROB20300}, who hinted at exploiting the straight skeleton algorithm to generate the inset polygons. An optimization strategy is employed to find the shortest trajectory through the field by repeatedly offsetting the remainding shape and traversing all possible ways off filling the shape. The algorithm is relatively computationally intensive, what might be justified when using large agricultural machines but what was not necessary for the goals of this thesis as the benefit of this optimization would be relatively small.

Another field where trajectories have to be generated is in \textit{Computer Aided Machining} (CAM). The process of removing layers of material from a block of metal is quite similar (though inverse, usually) to what is achieved in this thesis. Many publications deal with the problem of multi-axis milling machines which are far more complex and are also able to move over the machined surface without problem because the machining head can be lifted -- something that is not possible with an autonomous ground vehicle.

One interesting publication in the CAM field is \cite{kao1998optimal} that presents a method to reduce gaps that are present when simply offsetting a polygon with spirals. The presented method could be a possible future improvement to the spiral fill algorithm of \autoref{sec:spiral_fill}.

The OpenCAM library has also been inspected...

	% all the algorithms go here
\subsection{Mathematical Discussion of Polygons}

The following mathematical definition of a polygon, has been taken from \cite{coxeter1967geometry}:

\enquote{A polygon may be defined as consisting of a number of points (called vertices) and an equal number of line segments (called sides), namely a cyclically ordered set of points in a plane, with no three successive points collinear, together with the line segments joining consecutive pairs of the points. In other words, a polygon is closed broken line lying in a plane}.

Polygons can have several properties that simplify or complicate their treatment:

\begin{description}
\item[Simple] A simple polygon is not self intersecting and has a well-defined interior and exterior.\cite{weisstein_simple_p}
\item[Convex] In the convex case any line can intersect the polygon only at two points. The interior all have to be smaller than 180°.\cite{weisstein_convex_p}
\item[Concave] A concave polygon can be intersected more than twice by a given line. Therefore, at least one interior angle has to be larger than 180°.\cite{weisstein_concave_p}
\item[Self-intersecting] A self intersecting polygon has at least one side which intersects with another side.
\end{description}

\begin{figure}
\centering
\begin{tikzpicture}[y=0.80pt,x=0.80pt,yscale=0.55, xscale=0.55, inner sep=0pt, outer sep=0pt]
  \path[draw=black,fill=black,line join=miter,line cap=butt,even odd rule,line
    width=0.800pt] (95.0000,103.7908) -- (50.0000,264.5050) -- (270.7143,278.0765)
    -- (268.5714,180.9336) -- (192.8571,113.7908) -- (95.0000,103.7908) -- cycle;
  \path[draw=black,fill=black,line join=miter,line cap=butt,even odd rule,line
    width=0.928pt] (377.5515,141.0290) -- (320.7928,240.1507) --
    (440.0823,219.4707) -- (457.3986,308.6089) -- (564.1820,137.4635) --
    (460.2846,160.2829) -- (391.9817,88.2592) -- (377.5515,141.0290) -- cycle;
  \path[draw=black,fill=black,line join=miter,line cap=butt,even odd rule,line
    width=0.631pt] (613.5194,155.6718) -- (619.2365,302.6427) --
    (717.1421,93.0649) -- (786.4622,339.4964) -- (823.6234,159.6680) --
    (613.5194,155.6718) -- cycle;
\end{tikzpicture}
\caption{Three different polygon types: (a) simple and convex, (b) simple and concave, (c) self-intersecting}
\label{straight_skel}
\end{figure}

\subsection{Spiral Filling}

The first method to cover the area of an arbitrary polygon is the spiral fill method using inset polygons that are created using the straight skeleton of the polygon.

\subsubsection{Straight Skeleton}

For the case of this thesis, the most interesting property of the straight skeleton is the ability to easily obtain inset polygons with an arbitrary offset. The straight skeleton is defined as the topolgical skeleton of a polygon that is created by moving the edges parallel to themselves inwards at a constant speed and observing the intersections of the vertices (first described by Aichholzer et al. \citet{Aichholzer:jucs_1_12:a_novel_type_of}). 
It is similar to the median axis of a polygon, but unlike the median axis it is not defined to have a constant distance to the polygon edges. 
Another commonly used offset mechanism for polygons in motion planning is the Minkowski sum. However, there is no defined Minkowski subtraction, which makes the creation of inset polygons more complicated\footnote{It is possible to create an enclosing polygon, subtract the original polygon and offset the enclosing polygon with hole by taking the minkowski sum (which also offsets the \enquote{hole}).}. An efficient implementation to compute the straight skeleton is discussed in \citet{huber2010computing}.

To create a spiral trajectory, two events that occur during the creation of the straight skeleton, have to be kept in mind (visible in \autoref{straight_skel}): 

\begin{itemize}
\item Edge event: depending on the length difference between the edges, one edge might be reduced to zero sooner than the others, resulting in an edge event. The neighboring edges are adjacent after the event. At this point, the inset polygon will be reduced by one vertex.
\item Split event: a concave polygon will, at some point during the shrinking process, intersect itself. At the intersection point, a split event happens. After the split event, the number of inset polygons is increased by one.
\end{itemize}

\begin{figure}
\centering
\begin{tikzpicture}[y=0.80pt,x=0.80pt,yscale=-1, inner sep=0pt, outer sep=0pt]
  \path[draw=black,dash pattern=on 3.29pt,line join=miter,line cap=butt,miter
    limit=10.00,line width=1pt] (203.1137,220.5582) --
    (189.0787,206.5192)(203.1137,220.5582) --
    (213.1929,206.5192)(225.0684,323.4860) --
    (225.0684,242.8722)(219.3083,320.6079) --
    (189.0787,363.7948)(219.3083,320.6079) --
    (225.0684,323.4860)(219.3083,320.6079) --
    (203.1137,220.5582)(326.5591,238.1899) --
    (357.8705,255.1070)(326.5591,238.1899) --
    (357.8705,206.5192)(253.1386,279.2212) --
    (321.8807,279.2212)(257.0984,290.7375) --
    (357.8705,303.3315)(257.0984,290.7375) --
    (253.1386,279.2212)(257.0984,290.7375) --
    (225.0684,323.4860)(271.8559,254.7477) --
    (326.5591,238.1899)(271.8559,254.7477) --
    (237.3032,206.5192)(271.8559,254.7477) -- (253.1386,279.2212);
  \path[draw=black,line join=miter,line cap=butt,miter limit=10.00,line
    width=1pt] (189.0787,206.5192) -- (189.0787,363.7948) --
    (357.8705,303.3315) -- (321.8807,279.2212) -- (357.8705,255.1070) --
    (357.8705,206.5192) -- (237.3032,206.5192) -- (225.0684,242.8722) --
    (213.1929,206.5192) -- cycle;
  \path[draw=black,line join=miter,line cap=butt,miter limit=10.00,line
    width=1pt] (382.9398,207.8565) -- (382.9398,365.1321) --
    (551.7316,304.6688) -- (515.7419,280.5585) -- (551.7316,256.4443) --
    (551.7316,207.8565) -- (431.1683,207.8565) -- (418.9296,244.2055) --
    (407.0541,207.8565) -- cycle;
  \path[draw=black,line join=miter,line cap=butt,miter limit=10.00,line
    width=1pt] (382.9398,207.8565);
  \path[draw=black,line join=miter,line cap=butt,miter limit=10.00,line
    width=1pt] (520.4203,239.5272) -- (453.8415,239.5272) --
    (429.0088,314.3887) -- (481.5524,295.6714) -- (458.8792,280.1953) --
    (520.0610,239.5272)(421.0891,322.3044) -- (492.3501,297.1124) --
    (467.8766,280.1953) -- (524.7393,241.6867) -- (524.7393,235.2081) --
    (450.6003,235.2081) -- (421.8077,321.9452)(417.4886,323.7454) --
    (410.2914,305.0281) -- (410.2914,325.9050) --
    (417.4886,323.7454)(444.4809,298.5534) -- (459.9570,293.1526) --
    (448.4407,285.2369) -- (444.4809,298.5534)(461.3980,249.6063) --
    (486.5900,249.6063) -- (453.4783,271.9203) --
    (461.3980,249.2471)(396.9749,221.5323) -- (396.9749,344.9777) --
    (520.4203,300.7129) -- (491.9908,280.5585) -- (537.6966,248.8839) --
    (537.6966,221.8916) -- (441.2436,221.8916) -- (418.9296,285.5961) --
    (396.9749,221.8916);
  \path[draw=gray,dash pattern=on 3.29pt,line join=miter,line cap=butt,miter
    limit=10.00,line width=1pt] (397.0360,221.6940) --
    (383.0010,207.6550)(397.0360,221.6940) --
    (407.1152,207.6550)(418.9907,324.6218) --
    (418.9907,244.0080)(413.2306,321.7437) --
    (383.0010,364.9306)(413.2306,321.7437) --
    (418.9907,324.6218)(413.2306,321.7437) --
    (397.0360,221.6940)(520.4814,239.3257) --
    (551.7928,256.2428)(520.4814,239.3257) --
    (551.7928,207.6550)(447.0609,280.3570) --
    (515.8030,280.3570)(451.0207,291.8733) --
    (551.7928,304.4674)(451.0207,291.8733) --
    (447.0609,280.3570)(451.0207,291.8733) --
    (418.9907,324.6218)(465.7782,255.8835) --
    (520.4814,239.3257)(465.7782,255.8835) --
    (431.2255,207.6550)(465.7782,255.8835) -- (447.0609,280.3570);

\end{tikzpicture}
\caption{Straight skeleton and generated inset polygons (right). Split and edge events are well visible. Figure modified from \cite{Aichholzer:jucs_1_12:a_novel_type_of}.}
\end{figure}


The inset polygons are used to create a spiral fill for the polygons. The procedure is as follows:

\begin{itemize}
\item[(0)] The straight skeleton is generated
\item[(1)] The first inset polygon is created. The inset distance is the constant width of the rake divided by the number of vertices of the polygon. Through dividing the inset length by the number of vertices in the polygon, one revolution of the spiral will travel one rake distance inwards.
\item[(2)] If a split event has happened, then it is decided which polygon should be used to extend the current spiral (that is the one with the closer point to the current position). All other newly created polygons are recursively filled by the same algorithm (starting at 0). %Additionally, a starting point to the spiral is passed, so that the beginning of the next spiral will be close to the current one. (The procedure restarts with each split polygon as input at (0)).
\item[(3)] The closest point to the current point on the inset polygon is searched ($v_n$). The clockwise next vertex of the inset polygon ($v_{n+1}$) is appended to the current spiral
\item[(4)] The next inset polygon is generated with inset length divided by the number of vertices of the previous inset polygon, and the process continues at (3).

\end{itemize}

\begin{algorithm}[H]
\begin{algorithmic}
\caption{Spiral Filling}\label{spiral_fill}

\Function{createSpiralFill}{Polygon p, Point startPoint}
\State $RakeWidth \gets \text{(const. rake width for BeachBot)}$
\State $result \gets \text{empty list of points}$
\State $ss \gets \text{getStraightSkeleton}(p)$
\State $lOffset = RakeWidth/p.numVertices()$
\If{$startPoint$} $currPoint \gets startPoint$ 
\Else ~$ currPoint \gets p.firstVertex$ 
\EndIf
\State $insetPolys \gets getOffsetPolygons(ss, lOffset)$`
\While{$insetPolys.numPolys() \geq 1$}
\If{$insetPolys.numPolys() > 1$}
	\State $closestPoly = searchClosestPolygon(insetPolys, currPoint)$
	\ForAll{$\lbrace poly \in insetPolys | poly \not\in closestPoly\rbrace$}
		\State $createSpiralFill(poly, currPoint)$
	\EndFor
	\State $ss \gets getStraightSkeleton(closestPoly)$
	\State $lOffset = RakeWidth/closestPoly.size()$
	\State $insetPolys \gets getOffsetPolygons(ss, lOffset)$
\EndIf
\State $index \gets findClosestIndex(currPoint, insetPolys.firstPoly)$
\State $currPoint \gets insetPolys.firstPoly.pointFromIndex(index + 1)$
\State $result.appendToList(currPoint)$
\State $insetPolys \gets getOffsetPolygons(ss, lOffset)$
\EndWhile
\EndFunction

\end{algorithmic}

\end{algorithm}

The algorithm is both displayed in pseudo code \autoref{spiral_fill} and graphically in  \autoref{fig:insetting}. 

\begin{figure}[htbp]
	\centering
    \begin{subfigure}[b]{0.45\textwidth}
    		\includegraphics[width=\textwidth]{images/algorithms/spiral_fill/2.pdf}
		\caption{The first inset polygon and the first part of the spiral line}
    \end{subfigure}
    ~
    \begin{subfigure}[b]{0.45\textwidth}
    		\includegraphics[width=\textwidth]{images/algorithms/spiral_fill/3.pdf}
    		\caption{Next inset polygon generated}
    \end{subfigure}\\
    \begin{subfigure}[b]{0.45\textwidth}
    		\includegraphics[width=\textwidth]{images/algorithms/spiral_fill/4.pdf}
    		\caption{The polygon right before the \textit{split} happens}
    \end{subfigure}~
    \begin{subfigure}[b]{0.45\textwidth}
    		\includegraphics[width=\textwidth]{images/algorithms/spiral_fill/done.pdf}
    		\caption{After split, next polygon was found for continuing the current spiral}

    \end{subfigure}
        \begin{subfigure}[b]{0.45\textwidth}
    		\includegraphics[width=\textwidth]{images/algorithms/spiral_fill/after_done_2.pdf}
    		\caption{Continuing spiral 1 and starting the second spiral. Note how the start point of the second spiral is the closest point to the endpoint of the first.} \label{splitevent}
    \end{subfigure}
\\
        \begin{subfigure}[b]{0.45\textwidth}
    		\includegraphics[width=\textwidth]{images/algorithms/spiral_fill/complete_done.pdf}
    		\caption{The completed spiral with all inset polygons removed.}
    \end{subfigure}
	\caption{Generating the fill spiral. Note that this is only an example for illustration purposes. The density of inset polygons for a real application is much higher.} \label{fig:insetting}
\end{figure}

\begin{figure}
\centering
\includegraphics[width=0.6\textwidth]{images/algorithms/spiral_fill/spiral_real.pdf}
\caption{Generated spiral} \label{fig:gen_spiral}
\end{figure}

\subsection{Back and Forth Filling}
\todo{change name?}

This fill method is quite straightforward: The polygon is filled by a number of lines that are parallel to each other and clipped at the polygon edges. The direction of the lines can be freely chosen.

To place the lines, a starting point is determined. If the chosen line direction is inclined more than 45°, the leftmost vertex is used as starting point, or else if the inclination is smaller, the bottommost vertex is selected.

Starting from the start point, lines in the specified direction are placed and the polygon edges are tested for intersection. If two intersections for a given line are found, a line segment with those two points is added to the resulting trajectory. If no two intersections are found anymore, the algorithm stops.

This method works very well for convex polygons, but has drawbacks for non-convex polygons, since a non convex polygon can have more than two intersections for any given line. Therefore it requires the polygon to be decomposed into convex parts. It was decided to use the optimal convex partitioning with the algorithm by Greene, described in \citet{greene1983decomposition}. The decomposed parts have vertices that coincide with the original vertices. Since it is an optimal convex partitioning algorithm, the number of created convex polygons is minimal (therefore the size of each decomposed part is maximized). Having larger decomposed parts is positive for the trajectory, because fewer turns in general reduce the drawing time and make for a more consistent look.

\section{Path Generation}
As already mentioned, to finally create a drawing all elements have to be connected by support trajectories that are not part of the drawing and where the robot drives with the rake lifted. The supporting paths should have two properties: The total distance of all support paths should be as small as possible and the curvature of the connections should be limited.

As previously defined, a drawing consists of the three different types: Lines, polygons and filled polygons. Lines and polygons differ in the way they can be connected, as illustrated in \autoref{fig:connect}. A line has two connection points and is traversed from one end to the other. A polygon however can be entered at any vertex, but can only be exited at the same vertex so that the polygon is closed. Filled polygons work the same as the regular polygon in that sense, since the spiral and the back and forth filling create a polyline that is inserted into the filled polygon.

\begin{figure}
\includegraphics[width=0.8\textwidth]{images/path_planning/traversal.pdf}
\caption{Possible entry- and exit vertices and direction of traversal for polylines and polygons. Note that the polygon could also be traversed in clockwise direction.}
\end{figure}

\subsection{Traveling Salesman Problem}

The task of connecting the drawing elements is similar to that of a Traveling Salesman Problem.
The \textit{Traveling Salesman Problem} (TSP) is the problem of finding the minimum-weight Hamiltonian Circuit in a weighted graph. A weighted graph is a graph where every edge between two vertices has a certain weight. The Hamiltonian Circuit is defined as a tour through the graph, that travels to every vertex exactly once. It is called traveling salesman problem because in the historical context the vertices were cities, the weights Euclidean distances and the salesman, seeking to minimize the distance traveled to do a roundtrip through all the cities in a given tour, would seek to obtain a solution for this problem. However, one of the properties of the traveling salesman problem that make this problem difficult to solve is that it is \textit{Non-deterministic Polynomial-time hard} (NP-hard) which means that, although the non-existence has not yet been proven, there is as of now no polynomial-time solution. If no heuristic is used, the amount of solutions that have to be searched in order to test all available possibilities is $n!$.

The weights of the problem are usually defined in a distance matrix  $M^{n \times n}$ matrix, where the elements are given by $d_{ij}$.

The following properties for a general Traveling Salesman Problem are defined:

\begin{description}
\item[Symmetric] A TSP is symmetric if all distances between every node pair are symmetric (equal) in both directions ($d_{ij} = d_{ji} ~ \forall ~ i, j$).
\item[Metric] In a metric TSP, all distances conform to the triangle inequality $d_{xy} \leq d_{xz} + d_{zy} $ which is, for example, true if the distances are calculated using the Euclidean distance formula between two points: $d_{ij} = \sqrt{(x_i -x_j)^2 + (y_i - y_j)^2}$ but also for the so called Manhattan distance which is defined as ${d_{ij}^M} = |x_i-x_j| + |y_i - y_j|$.
\item[Asymmetric] If $d_{ij} \neq d_{ji}$ for at most one distance pair, then the TSP is asymmetric. The triangle inequality is not guaranteed to be fulfilled any more.
\end{description}

The easiest heuristic to the TSP is the nearest neighbour search. From a given startpoint the nearest, unvisited vertex is searched and connected. This is done until no more unvisited elements exist. Positive about the nearest neighbour approach is that the complexity is only growing linear to the search size. However, the obtained solutions are often of unsatisfying quality.

Another standard heuristic is the branch and bound method. It works by splitting the set of possible solution into two sets and by calculating a upper and lower bound for both sets. If the upper bound of the first is lower than the lower bound of the second, the second is discarded. During the course of this thesis a variant of the depth-first branch and bound search was implemented. First, the graph is traversed until a tour is completed. Afterwards, another tour is recursively started. As soon as the traveled distance of the entire tour in the new branch gets higher than the current minimum tour, the branch is discarded. While this already reduces the search space, the effect becomes relatively small on larger problems (e.g. the first 6 out of 15 nodes might only seldomly span a tour where the distance is higher than the current minimum, and it gets only worse). The implementation has not been very mature, and it actually produces an optimal tour in the current implementation, which is not necessarily desired in a heuristic, that should sacrifice quality for speed. With more level-wise bounds it could have been further improved. 

While the branch-and-bound implementation was not very mature and could have been optimized by a good margin, it became clear that, for a drawing of reasonable size, a state-of-the-art implementation had to be found. Currently there are, among others, two well-known state of the art implementations for the TSP\footnote{according to \url{http://www.adaptivebox.net/CILib/code/tspcodes_link.html}}: Concorde\footnote{\url{http://www.math.uwaterloo.ca/tsp/concorde.html}} and the Improved Lin-Kernighan Heuristic of Helsgaun (LKH)\cite{helsgaun2000effective}\cite{kernighan1970efficient}. The Concorde solver is described by \cite{hornik2007tsp} as \enquote{one of the best exact TSP solvers currently available}. However, it only works with symmetric distance matrices. While it is possible to transform a general non-Euclidean asymmetric problem into a symmetric one, the resulting matrix is bigger (in the case of \cite{kumar1996asymmetric} the transformed distance matrix is of size $2n \times 2n$). Contrary to the Concorde solver, the Improved LKH of Helsgaun is able to directly work with asymmetric distance matrices, which makes it an ideal candidate for the purpose of this thesis. Furthermore, it is using a heuristic which is not guaranteed to obtain optimal solutions, but optimal solutions are arguably not needed for the case of a drawing.

The author, Keld Helsgaun, also demonstrates how the implementation is suited to solve the equality Generalized\citep{helsgaun2013equality} as well as the clustered TSP\cite{helsgaun2014solving}. A combination of both cases is used in this thesis to find a high quality tour through the drawing of.

The LKH solver uses the \textit{TSPLIB} interface to read and write the problems. The TSPLIB is a benchmark collection of various problems where some of them have known optimal solutions.

%The final solution to the minimum connection problem was to use a state of the art TSP solver\cite{helsgaun2000effective}, which employs the Lin-Kernhighan-Heuristic\cite{kernighan1970efficient} (LKH) to approximately solve the Traveling Salesman Problem. It is, unlike many other TSP solver implementations that require the triangle inequality to hold, also well suited to solve assymetric problems.
% general definition
% all three methods we tried, including LKH
\subsection{Adaptation of Traveling Salesman Problem for the Algorithm}

To find a suited tour with the generic LKH solver, the correct weights for the graph have to be specified. This happens in logical steps:

\begin{itemize}
\item On polylines, all vertices that are not the first or last node are removed, since they can never be accessed without entering at either the first or last node 
\item Polygons can be entered at any node. However, once entered, the polygon cannot be exited at any location but must be traversed completely. To enforce this, the weights on the polygon edges are set to be zero for the next vertex in clockwise direction and infinity for all other nodes of the polygon.
\item Every node is only visited once. This leads to problems in polygons, where the tour should be closed. There are two possible solutions: Double cities or weight shifting. Since the double cities approach is doubling the number of cities it is clearly the less optimal approach. Because it is known that entering at node $n$ will result in the visitor ending up at node $n-1$ (all edges are zero), using the weight shifting method, the outgoing weights of the polygon at node $n$ are shifted to node $n-1$. Thereby, the elementwise symmetry is restored and a optimal solution can be found with a generic TSP solver. In a post processing step, the polygon is closed again.
\item All other edge weights are the euclidean distances between the vertex pair
\end{itemize}

A regular TSP tour is closed. This implies that a regular tour has a tendency to go back to the starting point after diverging into another direction at the beginning. The solution that was found is to enforce a defined start point to be inserted. The outgoing weights of the start point are either euclidean distances or defined to be the same to every node in the graph. If they are euclidean, chances are very high that the starting line is the nearest neighbour. If the outgoing weights are all defined to be $1$ the LKH can find the best suited start point on it's own because the startpoint will not induce any preference for any of the nodes.

The ingoing weights for the startpoint are chosen to be equal for all nodes. Thus, the TSP will never optimize towards traveling back to the start point.

\section{Smooth Line Connections}

While not required by the robot kinematics of the BeachBot (which can turn on the spot), generating smooth connections is beneficial to the path converter that translates the generated rake path into a robot path that is drivable by the bot. If the curvature at a given point in the connection is too high, it is not possible for the path converter to find a converging solution which makes tedious manual work needed to adjust the curvature of the connections until the converter is able to find a solution. The rounded connections would also create a nice visual effect for spectators.

Ideally a way would have to be found that limits the curvature of the connection path.

Curvature is defined as the inverse of the radius of the circle that the tangent produces at any given point in the curve. For a two dimensional curve, the curvature $\kappa$ is defined as 
$$\kappa = \frac{|x'y''-y'x''|}{(x'^2+y'^2)^{3/2}}$$


\subsubsection{Beziér Splines}

A first approach to generate more curved connections was to use Beziér splines.
The start- and endpoint of the beziér spline is trivially found as the start- and endpoint of the connection. As first solution, we used beziér splines of 3rd order. Beziér splines of 3rd order only yield 2 control points, which can, by moving them along the desired tangent, easily be used to create a connection that is smooth in the start and endpoint. However, the curvature for the complete curve can not be set because the two control points offer to few degrees of freedom. A beziér curve of 5th degree (quintic) has enough DOF to constrain the connection in terms of curvature.

The quintic Beziér curve consists of 6 control points $P_0 ... P_5$ that define the shape of the curve. $P_0$ and $P_5$ are trivially chosen because they coincide with the start- respectively the endpoint of the curves that should be connected. $P_1$ and $P_4$ are also easy to choose as they have to lie on the tangents of the curves that should be connected. $P_2$ and $P_3$ on the other hand are more difficult to obtain. Even after an extensive search through available literature it remained unclear if an analytical solution to this problem can be found or not, since the equation for curvature is getting quite complicated if expanded. In \cite{doi:10.1137/1.9781611971521.ch5} three approaches to generate beziér splines with monotone curvature are discussed. \cite{choi2010piecewise} uses piecewise 3rd degree bezier curves to create a curvature and corridor constrained trajectory.  [to be expanded]

\subsubsection{Spiro Splines}

Spiro splines, introduced by \cite{levien2009spiral} are a different approach to designing fair curves, initially for the purpose of designing fonts. They have several properties which make them well-suited for the task at hand:

They offer 4 different control points to control the shape of the curve. In contrast to beziér curves, spiro spline control points are always passed by the generated curve, whereas the bezier curve only goes through the first and last control point. The 4 different control points, denoted by a single character, of spiro splines are:

\begin{itemize}
\item[\texttt{v}] Corner point
\item[\texttt{c}] A $G^2$ continous constraint. The curvature  on the left side is the same as on the right side ($\kappa_l = \kappa_r$).
\item[\texttt{o}] Similiar to \texttt{c}, a $G^4$ continous constraint. Not only $\kappa_l = \kappa_r$ is true, but also the first and second derivative of the curvature is constrained ($\kappa_l' = \kappa_r'$, $\kappa_l'' = \kappa_r''$).
\item[\texttt{[}] A straight-to-curved control point that acts like a tangent constraint in this case.
\item[\texttt{]}] A curved-to-straight control point that also acts like a tangent constraint here.
\end{itemize}

The author, Raph Levien, has licensed his implementation \footnote{libspiro: \url{http://www.levien.com/spiro/} } of spiro splines under the GPLv2, which makes it possible to be used by this thesis. The implementation is capable of being used for realtime editing. That guarantees that the curve generation would not be the bottleneck of the application in terms of time consumption. The output of the library is a set of Beziér curves which are easier to handle in regular graphics programs.

\paragraph{Heuristic for Setting the Control Points}

To find suitable locations for the spiro spline control points, a heuristic was used.

All connection constraints can be expressed by 5 variables: Connection length ($d$), tangents with angles $\alpha$ and $\beta$ and the curvature limit $\kappa$, as shown in \autoref{fig:connection_vars}. For the calculation of the control points, the difference between the two angles was defined as $\delta = \alpha - \beta$. It equals the angle between the two tangent vectors. 

Finding the first 4 points of the curve is straightforward: The first control point is a corner point at the endpoint of the first element. The second point is a straight-to-curve point, that is positioned an infinitesimally small distance in the direction of the tangent from the first point. This constrains the \enquote{outgoing} tangent. Vice versa, the same control points are set at the end of the curve, where the element that is connected with begins. Thus both tangent constrains are fullfilled. Because the spiros do not offer a direct way of setting the maximum and minimum curvatures, zero to two more control points have to be added. The curvature can be limited by positioning a $G^2$ control point at distance $2 * R$ from the start- and endpoint. This limits the curvature to the left and to the right to be the same. Since the highest curvature between the startpoint and the $G^2$ point would be a circular arc with radius $R$ this limits the curvature to $\kappa = 1/R$, as long as both $G^2$ points are keeping a distance of $2*R$ as well.

The heuristic differentiates 3 cases:

If the both tangent vectors $\alpha$ and $\beta$ have a similar direction and the circle that is described by them and $d$ has a radius that is in the range of $R < r < 2*R$ then no intermediate $G^2$ points are set because the connection will already be smooth and optimal.

Otherwise, the $G^2$ points are set by elongating the tangent vector to $2*R$ and rotating it by $0.5 * \alpha$. This is done to reduce the size of the resulting curve, which is demonstrated in .. Fig ...

As discussed, the two $G^2$ points, called $c_1$ and $c_2$ are closer than $2 * R$ to each other, the positions have to be recalculated. This happens by rotating the $c_1$ and $c_2$ points gradually in different direction until positions are found that conform to the distance constraint. By rotating both points about the same angle, a symmetry is kept.

If the distance $d$ is smaller than 

\begin{figure}

\usetikzlibrary{calc}

\definecolor{cb3b3b3}{RGB}{179,179,179}
\definecolor{ccccccc}{RGB}{204,204,204}
\definecolor{cffffff}{RGB}{255,255,255}

\begin{tikzpicture}[y=0.80pt,x=0.80pt,yscale=-1, inner sep=0pt, outer sep=0pt]
\centering
  \path[draw=black,line join=miter,line cap=butt,line width=0.800pt]
    (96.0814,121.3474) -- (115.9166,172.6195) -- (330.7355,172.6195) --
    (371.5287,119.1019);
  \path[draw=black,line join=miter,line cap=butt,line width=0.800pt]
    (115.9129,172.6241) -- (69.8665,172.6241);
  \path[draw=cb3b3b3,dash pattern=on 0.34pt off 0.17pt,line join=miter,line
    cap=butt,miter limit=4.00,dash phase=0.201pt,line width=0.800pt]
    (330.6888,172.6195) -- (366.5496,172.6195);
  \path[cm={{1.45393,0.0,0.0,1.45393,(-471.01666,-377.22731)}},draw=ccccccc,miter
    limit=4.00,line width=0.550pt] (564.5997,360.8878)arc(-52.961:0.593:21.466);
  \path[cm={{0.52395,0.0,0.0,0.52395,(41.81533,-25.47312)}},draw=cb3b3b3,miter
    limit=4.00,dash phase=0.960pt,line width=1.527pt]
    (94.9543,377.5908)arc(179.987:249.624:46.467);
  \path[fill=black,line width=0.800pt] (94.482018,167.26112) node[above right]
    (text4046) {$\alpha$};
  \path[fill=black] (337.53653,168.90082) node[above right] (text4046-2)
    {$\beta$};
  \path[draw=black,line join=miter,line cap=butt,line width=0.800pt]
    (114.8543,177.9195) -- (114.8543,193.7975);
  \path[draw=black,line join=miter,line cap=butt,line width=0.800pt]
    (114.8543,186.1205) -- (330.7957,186.1205);
  \path[draw=black,line join=miter,line cap=butt,line width=0.800pt]
    (330.7957,177.9195) -- (330.7957,193.7975);
  \path[fill=cffffff,line width=0.800pt,rounded corners=0.0000cm]
    (199.5575,177.5072) rectangle (228.2820,192.5707);
  \path[fill=black,line width=0.800pt] (205.50471,192.37236) node[above right]
    (text4081) {d};
\end{tikzpicture}
\caption{Variables for the connection between two elements}
\label{fig:connections_vars}
\end{figure}
